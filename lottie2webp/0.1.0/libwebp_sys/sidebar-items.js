initSidebarItems({"constant":[["ALL_VALID_FLAGS",""],["ALPHA_FLAG",""],["ANIMATION_FLAG",""],["EXIF_FLAG",""],["ICCP_FLAG",""],["MODE_ARGB",""],["MODE_Argb",""],["MODE_BGR",""],["MODE_BGRA",""],["MODE_LAST",""],["MODE_RGB",""],["MODE_RGBA",""],["MODE_RGBA_4444",""],["MODE_RGB_565",""],["MODE_YUV",""],["MODE_YUVA",""],["MODE_bgrA",""],["MODE_rgbA",""],["MODE_rgbA_4444",""],["VP8_ENC_ERROR_BAD_DIMENSION",""],["VP8_ENC_ERROR_BAD_WRITE",""],["VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY",""],["VP8_ENC_ERROR_FILE_TOO_BIG",""],["VP8_ENC_ERROR_INVALID_CONFIGURATION",""],["VP8_ENC_ERROR_LAST",""],["VP8_ENC_ERROR_NULL_PARAMETER",""],["VP8_ENC_ERROR_OUT_OF_MEMORY",""],["VP8_ENC_ERROR_PARTITION0_OVERFLOW",""],["VP8_ENC_ERROR_PARTITION_OVERFLOW",""],["VP8_ENC_ERROR_USER_ABORT",""],["VP8_ENC_OK",""],["VP8_STATUS_BITSTREAM_ERROR",""],["VP8_STATUS_INVALID_PARAM",""],["VP8_STATUS_NOT_ENOUGH_DATA",""],["VP8_STATUS_OK",""],["VP8_STATUS_OUT_OF_MEMORY",""],["VP8_STATUS_SUSPENDED",""],["VP8_STATUS_UNSUPPORTED_FEATURE",""],["VP8_STATUS_USER_ABORT",""],["WEBP_CHUNK_ALPHA",""],["WEBP_CHUNK_ANIM",""],["WEBP_CHUNK_ANMF",""],["WEBP_CHUNK_DEPRECATED",""],["WEBP_CHUNK_EXIF",""],["WEBP_CHUNK_ICCP",""],["WEBP_CHUNK_IMAGE",""],["WEBP_CHUNK_NIL",""],["WEBP_CHUNK_UNKNOWN",""],["WEBP_CHUNK_VP8X",""],["WEBP_CHUNK_XMP",""],["WEBP_CSP_ALPHA_BIT",""],["WEBP_CSP_UV_MASK",""],["WEBP_DECODER_ABI_VERSION",""],["WEBP_DEMUX_ABI_VERSION",""],["WEBP_DEMUX_DONE",""],["WEBP_DEMUX_PARSED_HEADER",""],["WEBP_DEMUX_PARSE_ERROR",""],["WEBP_DEMUX_PARSING_HEADER",""],["WEBP_ENCODER_ABI_VERSION",""],["WEBP_FF_BACKGROUND_COLOR",""],["WEBP_FF_CANVAS_HEIGHT",""],["WEBP_FF_CANVAS_WIDTH",""],["WEBP_FF_FORMAT_FLAGS",""],["WEBP_FF_FRAME_COUNT",""],["WEBP_FF_LOOP_COUNT",""],["WEBP_HINT_DEFAULT",""],["WEBP_HINT_GRAPH",""],["WEBP_HINT_LAST",""],["WEBP_HINT_PHOTO",""],["WEBP_HINT_PICTURE",""],["WEBP_MAX_DIMENSION",""],["WEBP_MUX_ABI_VERSION",""],["WEBP_MUX_BAD_DATA",""],["WEBP_MUX_BLEND",""],["WEBP_MUX_DISPOSE_BACKGROUND",""],["WEBP_MUX_DISPOSE_NONE",""],["WEBP_MUX_INVALID_ARGUMENT",""],["WEBP_MUX_MEMORY_ERROR",""],["WEBP_MUX_NOT_ENOUGH_DATA",""],["WEBP_MUX_NOT_FOUND",""],["WEBP_MUX_NO_BLEND",""],["WEBP_MUX_OK",""],["WEBP_PRESET_DEFAULT",""],["WEBP_PRESET_DRAWING",""],["WEBP_PRESET_ICON",""],["WEBP_PRESET_PHOTO",""],["WEBP_PRESET_PICTURE",""],["WEBP_PRESET_TEXT",""],["WEBP_YUV420",""],["WEBP_YUV420A",""],["XMP_FLAG",""]],"fn":[["WEBP_ABI_IS_INCOMPATIBLE","Macro to check ABI compatibility (same major revision number)"],["WebPAnimDecoderDelete",""],["WebPAnimDecoderGetDemuxer",""],["WebPAnimDecoderGetInfo",""],["WebPAnimDecoderGetNext",""],["WebPAnimDecoderHasMoreFrames",""],["WebPAnimDecoderNew",""],["WebPAnimDecoderOptionsInit",""],["WebPAnimDecoderReset",""],["WebPAnimEncoderAdd",""],["WebPAnimEncoderAssemble",""],["WebPAnimEncoderDelete",""],["WebPAnimEncoderGetError",""],["WebPAnimEncoderNew",""],["WebPAnimEncoderOptionsInit",""],["WebPBlendAlpha",""],["WebPCleanupTransparentArea",""],["WebPConfigInit",""],["WebPConfigLosslessPreset",""],["WebPConfigPreset",""],["WebPDataClear",""],["WebPDataCopy",""],["WebPDataInit",""],["WebPDecode","Non-incremental version. This version decodes the full data at once, taking ‘config’ into account. Returns decoding status (which should be VP8_STATUS_OK if the decoding was successful). Note that ‘config’ cannot be NULL."],["WebPDecodeARGB","Same as WebPDecodeRGBA, but returning A, R, G, B, A, R, G, B… ordered data."],["WebPDecodeARGBInto",""],["WebPDecodeBGR","Same as WebPDecodeRGB, but returning B, G, R, B, G, R… ordered data."],["WebPDecodeBGRA","Same as WebPDecodeRGBA, but returning B, G, R, A, B, G, R, A… ordered data."],["WebPDecodeBGRAInto",""],["WebPDecodeBGRInto",""],["WebPDecodeRGB","Same as WebPDecodeRGBA, but returning R, G, B, R, G, B… ordered data. If the bitstream contains transparency, it is ignored."],["WebPDecodeRGBA","Decodes WebP images pointed to by ‘data’ and returns RGBA samples, along with the dimensions in *width and *height. The ordering of samples in memory is R, G, B, A, R, G, B, A… in scan order (endian-independent). The returned pointer should be deleted calling WebPFree(). Returns NULL in case of error."],["WebPDecodeRGBAInto",""],["WebPDecodeRGBInto",""],["WebPDecodeYUV","Decode WebP images pointed to by ‘data’ to Y’UV format(*). The pointer returned is the Y samples buffer. Upon return, *u and *v will point to the U and V chroma data. These U and V buffers need NOT be passed to WebPFree(), unlike the returned Y luma one. The dimension of the U and V planes are both (*width + 1) / 2 and (*height + 1)/ 2. Upon return, the Y buffer has a stride returned as ‘*stride’, while U and V have a common stride returned as ‘uv_stride’. Return NULL in case of error. () Also named Y’CbCr. See: http://en.wikipedia.org/wiki/YCbCr"],["WebPDecodeYUVInto","WebPDecodeYUVInto() is a variant of WebPDecodeYUV() that operates directly into pre-allocated luma/chroma plane buffers. This function requires the strides to be passed: one for the luma plane and one for each of the chroma ones. The size of each plane buffer is passed as ‘luma_size’, ‘u_size’ and ‘v_size’ respectively. Pointer to the luma plane (‘*luma’) is returned or NULL if an error occurred during decoding (or because some buffers were found to be too small)."],["WebPDemux",""],["WebPDemuxDelete",""],["WebPDemuxGetChunk",""],["WebPDemuxGetFrame",""],["WebPDemuxGetI",""],["WebPDemuxNextChunk",""],["WebPDemuxNextFrame",""],["WebPDemuxPartial",""],["WebPDemuxPrevChunk",""],["WebPDemuxPrevFrame",""],["WebPDemuxReleaseChunkIterator",""],["WebPDemuxReleaseIterator",""],["WebPEncode",""],["WebPEncodeBGR",""],["WebPEncodeBGRA",""],["WebPEncodeLosslessBGR",""],["WebPEncodeLosslessBGRA",""],["WebPEncodeLosslessRGB",""],["WebPEncodeLosslessRGBA",""],["WebPEncodeRGB",""],["WebPEncodeRGBA",""],["WebPFree","Releases memory returned by the `WebPDecode*()` functions (from `decode.h`)."],["WebPFreeDecBuffer","Free any memory associated with the buffer. Must always be called last. Note: doesn’t free the ‘buffer’ structure itself."],["WebPGetDecoderVersion","Return the decoder’s version number, packed in hexadecimal using 8bits for each of major/minor/revision. E.g: v2.5.7 is 0x020507."],["WebPGetDemuxVersion",""],["WebPGetEncoderVersion",""],["WebPGetFeatures","Retrieve features from the bitstream. The *features structure is filled with information gathered from the bitstream. Returns VP8_STATUS_OK when the features are successfully retrieved. Returns VP8_STATUS_NOT_ENOUGH_DATA when more data is needed to retrieve the features from headers. Returns error in other cases. Note: The following chunk sequences (before the raw VP8/VP8L data) are considered valid by this function: RIFF + VP8(L) RIFF + VP8X + (optional chunks) + VP8(L) ALPH + VP8 <– Not a valid WebP format: only allowed for internal purpose. VP8(L)     <– Not a valid WebP format: only allowed for internal purpose."],["WebPGetInfo","Retrieve basic header information: width, height. This function will also validate the header, returning true on success, false otherwise. ‘*width’ and ‘*height’ are only valid on successful return. Pointers ‘width’ and ‘height’ can be passed NULL if deemed irrelevant. Note: The following chunk sequences (before the raw VP8/VP8L data) are considered valid by this function: RIFF + VP8(L) RIFF + VP8X + (optional chunks) + VP8(L) ALPH + VP8 <– Not a valid WebP format: only allowed for internal purpose. VP8(L)     <– Not a valid WebP format: only allowed for internal purpose."],["WebPGetMuxVersion",""],["WebPIAppend","Copies and decodes the next available data. Returns VP8_STATUS_OK when the image is successfully decoded. Returns VP8_STATUS_SUSPENDED when more data is expected. Returns error in other cases."],["WebPIDecGetRGB","Returns the RGB/A image decoded so far. Returns NULL if output params are not initialized yet. The RGB/A output type corresponds to the colorspace specified during call to WebPINewDecoder() or WebPINewRGB(). *last_y is the index of last decoded row in raster scan order. Some pointers (*last_y, *width etc.) can be NULL if corresponding information is not needed. The values in these pointers are only valid on successful (non-NULL) return."],["WebPIDecGetYUV","Deprecated alpha-less version of WebPIDecGetYUVA(): it will ignore the alpha information (if present). Kept for backward compatibility."],["WebPIDecGetYUVA","Same as above function to get a YUVA image. Returns pointer to the luma plane or NULL in case of error. If there is no alpha information the alpha pointer ‘*a’ will be returned NULL."],["WebPIDecode","Instantiate a new incremental decoder object with the requested configuration. The bitstream can be passed using ‘data’ and ‘data_size’ parameter, in which case the features will be parsed and stored into config->input. Otherwise, ‘data’ can be NULL and no parsing will occur. Note that ‘config’ can be NULL too, in which case a default configuration is used. If ‘config’ is not NULL, it must outlive the WebPIDecoder object as some references to its fields will be used. No internal copy of ‘config’ is made. The return WebPIDecoder object must always be deleted calling WebPIDelete(). Returns NULL in case of error (and config->status will then reflect the error condition, if available)."],["WebPIDecodedArea","Generic call to retrieve information about the displayable area. If non NULL, the left/right/width/height pointers are filled with the visible rectangular area so far. Returns NULL in case the incremental decoder object is in an invalid state. Otherwise returns the pointer to the internal representation. This structure is read-only, tied to WebPIDecoder’s lifespan and should not be modified."],["WebPIDelete","Deletes the WebPIDecoder object and associated memory. Must always be called if WebPINewDecoder, WebPINewRGB or WebPINewYUV succeeded."],["WebPINewDecoder","Creates a new incremental decoder with the supplied buffer parameter. This output_buffer can be passed NULL, in which case a default output buffer is used (with MODE_RGB). Otherwise, an internal reference to ‘output_buffer’ is kept, which means that the lifespan of ‘output_buffer’ must be larger than that of the returned WebPIDecoder object. The supplied ‘output_buffer’ content MUST NOT be changed between calls to WebPIAppend() or WebPIUpdate() unless ‘output_buffer.is_external_memory’ is not set to 0. In such a case, it is allowed to modify the pointers, size and stride of output_buffer.u.RGBA or output_buffer.u.YUVA, provided they remain within valid bounds. All other fields of WebPDecBuffer MUST remain constant between calls. Returns NULL if the allocation failed."],["WebPINewRGB","This function allocates and initializes an incremental-decoder object, which will output the RGB/A samples specified by ‘csp’ into a preallocated buffer ‘output_buffer’. The size of this buffer is at least ‘output_buffer_size’ and the stride (distance in bytes between two scanlines) is specified by ‘output_stride’. Additionally, output_buffer can be passed NULL in which case the output buffer will be allocated automatically when the decoding starts. The colorspace ‘csp’ is taken into account for allocating this buffer. All other parameters are ignored. Returns NULL if the allocation failed, or if some parameters are invalid."],["WebPINewYUV","Deprecated version of the above, without the alpha plane. Kept for backward compatibility."],["WebPINewYUVA","This function allocates and initializes an incremental-decoder object, which will output the raw luma/chroma samples into a preallocated planes if supplied. The luma plane is specified by its pointer ‘luma’, its size ‘luma_size’ and its stride ‘luma_stride’. Similarly, the chroma-u plane is specified by the ‘u’, ‘u_size’ and ‘u_stride’ parameters, and the chroma-v plane by ‘v’ and ‘v_size’. And same for the alpha-plane. The ‘a’ pointer can be pass NULL in case one is not interested in the transparency plane. Conversely, ‘luma’ can be passed NULL if no preallocated planes are supplied. In this case, the output buffer will be automatically allocated (using MODE_YUVA) when decoding starts. All parameters are then ignored. Returns NULL if the allocation failed or if a parameter is invalid."],["WebPIUpdate","A variant of the above function to be used when data buffer contains partial data from the beginning. In this case data buffer is not copied to the internal memory. Note that the value of the ‘data’ pointer can change between calls to WebPIUpdate, for instance when the data buffer is resized to fit larger data."],["WebPInitDecBuffer","Initialize the structure as empty. Must be called before any other use. Returns false in case of version mismatch"],["WebPInitDecoderConfig","Initialize the configuration as empty. This function must always be called first, unless WebPGetFeatures() is to be called. Returns false in case of mismatched version."],["WebPIsAlphaMode",""],["WebPIsPremultipliedMode",""],["WebPIsRGBMode",""],["WebPMalloc","Allocates `size` bytes of memory. Returns NULL upon error. Memory must be deallocated by calling `WebPFree()`. This function is made available by the core `libwebp` library."],["WebPMemoryWrite",""],["WebPMemoryWriterClear",""],["WebPMemoryWriterInit",""],["WebPMuxAssemble",""],["WebPMuxCreate",""],["WebPMuxDelete",""],["WebPMuxDeleteChunk",""],["WebPMuxDeleteFrame",""],["WebPMuxGetAnimationParams",""],["WebPMuxGetCanvasSize",""],["WebPMuxGetChunk",""],["WebPMuxGetFeatures",""],["WebPMuxGetFrame",""],["WebPMuxNew",""],["WebPMuxNumChunks",""],["WebPMuxPushFrame",""],["WebPMuxSetAnimationParams",""],["WebPMuxSetCanvasSize",""],["WebPMuxSetChunk",""],["WebPMuxSetImage",""],["WebPPictureARGBToYUVA",""],["WebPPictureARGBToYUVADithered",""],["WebPPictureAlloc",""],["WebPPictureCopy",""],["WebPPictureCrop",""],["WebPPictureDistortion",""],["WebPPictureFree",""],["WebPPictureHasTransparency",""],["WebPPictureImportBGR",""],["WebPPictureImportBGRA",""],["WebPPictureImportBGRX",""],["WebPPictureImportRGB",""],["WebPPictureImportRGBA",""],["WebPPictureImportRGBX",""],["WebPPictureInit",""],["WebPPictureIsView",""],["WebPPictureRescale",""],["WebPPictureSmartARGBToYUVA",""],["WebPPictureView",""],["WebPPictureYUVAToARGB",""],["WebPPlaneDistortion",""],["WebPValidateConfig",""]],"struct":[["WebPAnimDecoder",""],["WebPAnimDecoderOptions",""],["WebPAnimEncoder",""],["WebPAnimEncoderOptions",""],["WebPAnimInfo",""],["WebPAuxStats",""],["WebPBitstreamFeatures","Features gathered from the bitstream"],["WebPChunkIterator",""],["WebPConfig",""],["WebPData",""],["WebPDecBuffer","Output buffer"],["WebPDecoderConfig","Main object storing the configuration for advanced decoding."],["WebPDecoderOptions","Decoding options"],["WebPDemuxer",""],["WebPIDecoder",""],["WebPIterator",""],["WebPMemoryWriter",""],["WebPMux",""],["WebPMuxAnimParams",""],["WebPMuxFrameInfo",""],["WebPPicture",""],["WebPRGBABuffer","view as RGBA"],["WebPYUVABuffer","view as YUVA"]],"type":[["VP8StatusCode","Enumeration of the status codes"],["WEBP_CSP_MODE",""],["WebPChunkId",""],["WebPDemuxState",""],["WebPEncCSP",""],["WebPEncodingError",""],["WebPFeatureFlags",""],["WebPFormatFeature",""],["WebPImageHint",""],["WebPMuxAnimBlend",""],["WebPMuxAnimDispose",""],["WebPMuxError",""],["WebPPreset",""],["WebPProgressHook",""],["WebPWriterFunction",""]],"union":[["__WebPDecBufferUnion",""]]});