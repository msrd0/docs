<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Initialize the scaling process for a given pair of source/destination frames. Must be called before any calls to sws_send_slice() and sws_receive_slice()."><title>sws_frame_start in ffmpeg_sys_next - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ffmpeg_sys_next" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ffmpeg_sys_next/index.html">ffmpeg_<wbr>sys_<wbr>next</a><span class="version">7.1.3</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">ffmpeg_sys_next</a></div><h1>Function <span class="fn">sws_frame_start</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ffmpeg_sys_next/tmp/tmp.t7w1TMSR76/mstickerlib-0.3.1/target/debug/build/ffmpeg-sys-next-97b588e0686b6f23/out/bindings.rs.html#15574-15578">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn sws_frame_start(
    c: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.SwsContext.html" title="struct ffmpeg_sys_next::SwsContext">SwsContext</a>,
    dst: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.AVFrame.html" title="struct ffmpeg_sys_next::AVFrame">AVFrame</a>,
    src: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*const </a><a class="struct" href="struct.AVFrame.html" title="struct ffmpeg_sys_next::AVFrame">AVFrame</a>,
) -&gt; <a class="type" href="../libc/primitives/type.c_int.html" title="type libc::primitives::c_int">c_int</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Initialize the scaling process for a given pair of source/destination frames.
Must be called before any calls to sws_send_slice() and sws_receive_slice().</p>
<p>This function will retain references to src and dst, so they must both use
refcounted buffers (if allocated by the caller, in case of dst).</p>
<p>@param c   The scaling context
@param dst The destination frame.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>       The data buffers may either be already allocated by the caller or
       left clear, <span class="kw">in </span>which case they will be allocated by the scaler.
       The latter may have performance advantages - e.g. <span class="kw">in </span>certain cases
       some output planes may be references to input planes, rather than
       copies.

       Output data will be written into this frame <span class="kw">in </span>successful
       sws_receive_slice() calls.</code></pre></div>
<p>@param src The source frame. The data buffers must be allocated, but the
frame data does not have to be ready at this point. Data
availability is then signalled by sws_send_slice().
@return 0 on success, a negative AVERROR code on failure</p>
<p>@see sws_frame_end()</p>
</div></details></section></div></main></body></html>