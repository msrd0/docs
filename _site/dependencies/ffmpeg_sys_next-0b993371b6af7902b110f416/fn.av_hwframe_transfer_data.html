<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Copy data to or from a hw surface. At least one of dst/src must have an AVHWFramesContext attached."><title>av_hwframe_transfer_data in ffmpeg_sys_next - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ffmpeg_sys_next" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ffmpeg_sys_next/index.html">ffmpeg_<wbr>sys_<wbr>next</a><span class="version">7.1.3</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">ffmpeg_sys_next</a></div><h1>Function <span class="fn">av_hwframe_transfer_data</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ffmpeg_sys_next/tmp/tmp.XunlGPWBVA/mstickerlib-0.3.2/target/debug/build/ffmpeg-sys-next-97b588e0686b6f23/out/bindings.rs.html#6279-6283">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn av_hwframe_transfer_data(
    dst: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.AVFrame.html" title="struct ffmpeg_sys_next::AVFrame">AVFrame</a>,
    src: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*const </a><a class="struct" href="struct.AVFrame.html" title="struct ffmpeg_sys_next::AVFrame">AVFrame</a>,
    flags: <a class="type" href="../libc/primitives/type.c_int.html" title="type libc::primitives::c_int">c_int</a>,
) -&gt; <a class="type" href="../libc/primitives/type.c_int.html" title="type libc::primitives::c_int">c_int</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Copy data to or from a hw surface. At least one of dst/src must have an
AVHWFramesContext attached.</p>
<p>If src has an AVHWFramesContext attached, then the format of dst (if set)
must use one of the formats returned by av_hwframe_transfer_get_formats(src,
AV_HWFRAME_TRANSFER_DIRECTION_FROM).
If dst has an AVHWFramesContext attached, then the format of src must use one
of the formats returned by av_hwframe_transfer_get_formats(dst,
AV_HWFRAME_TRANSFER_DIRECTION_TO)</p>
<p>dst may be “clean” (i.e. with data/buf pointers unset), in which case the
data buffers will be allocated by this function using av_frame_get_buffer().
If dst-&gt;format is set, then this format will be used, otherwise (when
dst-&gt;format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.</p>
<p>The two frames must have matching allocated dimensions (i.e. equal to
AVHWFramesContext.width/height), since not all device types support
transferring a sub-rectangle of the whole surface. The display dimensions
(i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but
also have to be equal for both frames. When the display dimensions are
smaller than the allocated dimensions, the content of the padding in the
destination frame is unspecified.</p>
<p>@param dst the destination frame. dst is not touched on failure.
@param src the source frame.
@param flags currently unused, should be set to zero
@return 0 on success, a negative AVERROR error code on failure.</p>
</div></details></section></div></main></body></html>