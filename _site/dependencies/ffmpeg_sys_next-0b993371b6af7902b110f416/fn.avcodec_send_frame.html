<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet() to retrieve buffered output packets."><title>avcodec_send_frame in ffmpeg_sys_next - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ffmpeg_sys_next" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ffmpeg_sys_next/index.html">ffmpeg_<wbr>sys_<wbr>next</a><span class="version">7.1.3</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">ffmpeg_sys_next</a></div><h1>Function <span class="fn">avcodec_send_frame</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ffmpeg_sys_next/tmp/tmp.XunlGPWBVA/mstickerlib-0.3.2/target/debug/build/ffmpeg-sys-next-97b588e0686b6f23/out/bindings.rs.html#8658">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn avcodec_send_frame(
    avctx: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.AVCodecContext.html" title="struct ffmpeg_sys_next::AVCodecContext">AVCodecContext</a>,
    frame: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*const </a><a class="struct" href="struct.AVFrame.html" title="struct ffmpeg_sys_next::AVFrame">AVFrame</a>,
) -&gt; <a class="type" href="../libc/primitives/type.c_int.html" title="type libc::primitives::c_int">c_int</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
to retrieve buffered output packets.</p>
<p>@param avctx     codec context
@param[in] frame AVFrame containing the raw audio or video frame to be encoded.
Ownership of the frame remains with the caller, and the
encoder will not write to the frame. The encoder may create
a reference to the frame data (or copy it if the frame is
not reference-counted).
It can be NULL, in which case it is considered a flush
packet.  This signals the end of the stream. If the encoder
still has packets buffered, it will return them after this
call. Once flushing mode has been entered, additional flush
packets are ignored, and sending frames will return
AVERROR_EOF.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>             For audio:
             If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
             can have any number of samples.
             If it is not set, frame-&gt;nb_samples must be equal to
             avctx-&gt;frame_size <span class="kw">for </span>all frames except the last.
             The <span class="kw">final </span>frame may be smaller than avctx-&gt;frame_size.</code></pre></div>
<p>@retval 0                 success
@retval AVERROR(EAGAIN)   input is not accepted in the current state - user must
read output with avcodec_receive_packet() (once all
output is read, the packet should be resent, and the
call will not fail with EAGAIN).
@retval AVERROR_EOF       the encoder has been flushed, and no new frames can
be sent to it
@retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires flush
@retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
@retval “another negative error code” legitimate encoding errors</p>
</div></details></section></div></main></body></html>