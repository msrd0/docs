searchState.loadedDescShard("clap_lex", 0, "Minimal, flexible command-line parser\nPosition within <code>RawArgs</code>\nSets the offset to the current position plus the specified …\nSets the offset to the size of this object plus the …\nCommand-line Argument\nCommand-line arguments\nA container for borrowed byte strings converted by this …\nA container for owned byte strings converted by this crate.\nEnumeration of possible methods to seek within an I/O …\nWalk through short flags within a <code>ParsedArg</code>\nSets the offset to the provided number of bytes.\nMove the iterator forward by <code>n</code> short flags\nReturns the byte string stored by this container.\nWraps a byte string, without copying or encoding …\nWraps a byte string, without copying or encoding …\nEquivalent to <code>String::clear</code>.\nEquivalent to <code>str::contains</code>.\nCreate a cursor for walking the arguments\nSafely print an argument that may contain non-UTF8 content\nEquivalent to <code>str::ends_with</code>.\nEquivalent to <code>str::ends_with</code> but accepts this type for the …\nEquivalent to <code>str::find</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<strong>NOTE:</strong> The argument returned will be the current binary.\nWraps a byte string, without copying or encoding …\nWraps a byte string, without copying or encoding …\nWraps a string, without copying or encoding conversion.\nWraps a string, without copying or encoding conversion.\nInject arguments before the <code>RawArgs::next</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>String::into_boxed_str</code>.\nConverts this representation back to a platform-native …\nReturns the byte string stored by this container.\nEquivalent to <code>OsString::into_string</code>.\nArgument is length of 0\nNo short flags left\nEquivalent to <code>str::is_empty</code>.\nAny remaining args?\nDoes the argument look like an argument escape (<code>--</code>)\nCan treat as a long-flag\nDoes the argument look like a number\nDoes the short flag look like a number\nCan treat as a short-flag\nDoes the argument look like a stdio argument (<code>-</code>)\nExample\nConverts a platform-native string into a representation …\nConverts a platform-native string into a representation …\nAdvance the cursor, returning the next <code>ParsedArg</code>\nAdvance the iterator, returning the next short flag on …\nAdvance the cursor, returning a raw argument value.\nAdvance the iterator, returning everything left as a value\nReturn the next <code>ParsedArg</code>\nReturn a raw argument value.\nReturns the length of the byte string stored by this …\nReturn all remaining raw arguments, advancing the cursor …\nEquivalent to <code>str::rfind</code>.\nEquivalent to <code>str::rsplit_once</code>.\nAdjust the cursor’s position\nEquivalent to <code>String::shrink_to_fit</code>.\nEquivalent to <code>str::split</code>, but empty patterns are not …\nEquivalent to <code>str::split_at</code>.\nEquivalent to <code>String::split_off</code>.\nEquivalent to <code>str::split_once</code>.\nEquivalent to <code>str::starts_with</code>.\nEquivalent to <code>str::starts_with</code> but accepts this type for …\nEquivalent to <code>str::strip_prefix</code>.\nEquivalent to <code>str::strip_suffix</code>.\nTreat as a long-flag\nConverts this representation back to a platform-native …\nTreat as a short-flag\nEquivalent to <code>OsStr::to_str</code>.\nConverts this string to the best UTF-8 representation …\nTreat as a value\nTreat as a value\nEquivalent to <code>str::trim_end_matches</code>.\nEquivalent to <code>str::trim_matches</code>.\nEquivalent to <code>str::trim_start_matches</code>.\nEquivalent to <code>String::truncate</code>.")