searchState.loadedDescShard("lazy_regex", 0, "With lazy-regex macros, regular expressions\nA compiled regular expression for searching Unicode …\nA configurable builder for a <code>Regex</code>.\nRepresents the capture groups for a single match.\nA value which is initialized on the first access.\nA compiled regular expression for searching Unicode …\nA configurable builder for a <code>Regex</code>.\nReturns the original string of this regex.\nReturns the original string of this regex.\nCompiles the pattern given to <code>RegexBuilder::new</code> with the …\nCompiles the pattern given to <code>RegexBuilder::new</code> with the …\nReturn an instance of <code>once_cell::sync::Lazy&lt;bytes::Regex&gt;</code> …\nReturn a lazy static <code>regex::bytes::Regex</code> checked at …\nExtract captured groups as a tuple of &amp;u8\nExtract the leftmost match of the regex in the second …\nTest whether an expression matches a lazy static …\nReplaces the leftmost match in the second argument using …\nReplaces all non-overlapping matches in the second argument\nDefine a set of lazy static statically compiled regexes, …\nReturns a fresh allocated set of capture locations that can\nReturns a fresh allocated set of capture locations that can\nReturns an iterator over the capture names in this regex.\nReturns an iterator over the capture names in this regex.\nThis routine searches for the first match of this regex in …\nThis routine searches for the first match of this regex in …\nReturns the same as <code>Regex::captures</code>, but starts the search …\nReturns the same as <code>Regex::captures</code>, but starts the search …\nReturns an iterator that yields successive non-overlapping …\nReturns an iterator that yields successive non-overlapping …\nReturns the number of captures groups in this regex.\nReturns the number of captures groups in this regex.\nThis is like <code>Regex::captures</code>, but writes the byte offsets …\nThis is like <code>Regex::captures</code>, but writes the byte offsets …\nReturns the same as <code>Regex::captures_read</code>, but starts the …\nReturns the same as <code>Regex::captures_read</code>, but starts the …\nThis configures whether to enable case insensitive …\nThis configures whether to enable case insensitive …\nThis configures CRLF mode for the entire pattern.\nThis configures CRLF mode for the entire pattern.\nCreates a new lazy value using <code>Default</code> as the initializing …\nSet the approximate capacity, in bytes, of the cache of …\nSet the approximate capacity, in bytes, of the cache of …\nThis configures dot-matches-new-line mode for the entire …\nThis configures dot-matches-new-line mode for the entire …\nExpands all instances of <code>$ref</code> in <code>replacement</code> to the …\nThis is a convenience routine for extracting the substrings\nThis routine searches for the first match of this regex in …\nThis routine searches for the first match of this regex in …\nReturns the same as <code>Regex::find</code>, but starts the search at …\nReturns the same as <code>Regex::find</code>, but starts the search at …\nReturns an iterator that yields successive non-overlapping …\nReturns an iterator that yields successive non-overlapping …\nShows the original regular expression.\nShows the original regular expression.\nShows the original regular expression.\nShows the original regular expression.\nForces the evaluation of this lazy value and returns a …\nForces the evaluation of this lazy value and returns a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to parse a string into a regular expression\nAttempts to parse a string into a regular expression\nGets the reference to the result of this lazy value if it …\nReturns the <code>Match</code> associated with the capture group at …\nGets the reference to the result of this lazy value if it …\nThis configures verbose mode for the entire pattern.\nThis configures verbose mode for the entire pattern.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>Lazy</code> returning the stored value.\nReturns true if and only if there is a match for the regex …\nReturns true if and only if there is a match for the regex …\nReturns the same as <code>Regex::is_match</code>, but starts the search …\nReturns the same as <code>Regex::is_match</code>, but starts the search …\nReturns an iterator over all capture groups. This includes …\nReturn an instance of <code>once_cell::sync::Lazy&lt;regex::Regex&gt;</code> …\nReturns the total number of capture groups. This includes …\nConfigures the line terminator to be used by the regex.\nConfigures the line terminator to be used by the regex.\nThis configures multi-line mode for the entire pattern.\nThis configures multi-line mode for the entire pattern.\nReturns the <code>Match</code> associated with the capture group named …\nSet the nesting limit for this parser.\nSet the nesting limit for this parser.\nCreates a new lazy value with the given initializing …\nCreate a new builder with a default configuration for the …\nCreate a new builder with a default configuration for the …\nCompiles a regular expression. Once compiled, it can be …\nCompiles a regular expression. Once compiled, it can be …\nThis configures octal mode for the entire pattern.\nThis configures octal mode for the entire pattern.\nReturn a lazy static Regex checked at compilation time and …\nExtract captured groups as a tuple of &amp;str.\nReturns an iterator that yields successive non-overlapping …\nExtract the leftmost match of the regex in the second …\nReturn an Option, with T being the type returned by the …\nTest whether an expression matches a lazy static regular …\nReplaces the leftmost match in the second argument using …\nReplaces all non-overlapping matches in the second argument\nDefine a set of lazy static statically compiled regexes, …\nReplaces the leftmost-first match in the given haystack …\nReplaces the leftmost-first match in the given haystack …\nReplaces all non-overlapping matches in the haystack with …\nReplaces all non-overlapping matches in the haystack with …\nReplaces at most <code>limit</code> non-overlapping matches in the …\nReplaces at most <code>limit</code> non-overlapping matches in the …\nReturns the end byte offset of the first match in the …\nReturns the end byte offset of the first match in the …\nReturns the same as <code>shortest_match</code>, but starts the search …\nReturns the same as <code>Regex::shortest_match</code>, but starts the …\nSets the approximate size limit, in bytes, of the compiled …\nSets the approximate size limit, in bytes, of the compiled …\nReturns an iterator of substrings of the haystack given, …\nReturns an iterator of substrings of the haystack given, …\nReturns an iterator of at most <code>limit</code> substrings of the …\nReturns an iterator of at most <code>limit</code> substrings of the …\nReturns the total number of capturing groups that appear …\nReturns the total number of capturing groups that appear …\nThis configures swap-greed mode for the entire pattern.\nThis configures swap-greed mode for the entire pattern.\nAttempts to parse a string into a regular expression\nAttempts to parse a string into a regular expression\nAttempts to parse a string into a regular expression\nAttempts to parse a string into a regular expression\nThis configures Unicode mode for the entire pattern.\nThis configures Unicode mode for the entire pattern.")